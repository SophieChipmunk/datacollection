\chapter{Project Methods}
\label{chap:projectsteps}


\section{Introduce Note Sets as a new note data container}
\label{noteset_goal}
We will introduce Note Sets as a new data container for referencing and persisting sets of note data. While these Note Sets will be exported to files, they do not constitute a file format in the narrower sense, but rather a new paradigm as how to think of collection of notes: No longer as notes that were recorded in the same transaction and thus in the same binary file (in earlier times this was the only way one could think of collections of notes), but as a collection of IDs.

The note set data container will have the following advantages:
\begin{itemize}
\item Compactness: Note Sets will be minimalist in the sense that notes are references by ID only. There is no additional information like annotation stored in the note set format.
\item Independency of file locations: With the introduction of MFX the actual location of a file in the pool becomes redundant. Therefore, the note set does not store any file paths.
\item Equivalence with respect to annotation: Unlike the Notelist format, Note Sets will no longer have an individual annotation per note. Rather, they have at most one annotation per note set, which is to be persisted in the note set's filename. Thus, note sets are considered equivalent with respect to annotation
\end{itemize}
Meanwhile, the new data container must at least satisfy the following requirements:
\begin{itemize}
\item Convertability to and from the existing Notelist format. The Notelist format has been established as the standard way of storing data sets in Currency Adaptation. Even if one were to pursue the goal of replacing the Notelist format by the Noteset format, convertability would be needed at least for a period of transition. The reasons for that are that a) Noteset import is supported by MCM however in a yet limited way. b) the Python MCM wrapper library mcmp, which is used to load notes and run algorithms from outside MCM, does currently not support the loading of Notesets.
 \item Differentiability. Since they are so minimalist, Note Sets are more ideal than previous formats for quick comparison. We need a way to compare and find the difference between Note Sets reliably and efficiently.
\end{itemize}

The Note Set data container is introduced in a small python library providing the abovementioned functionality. This library is deployed as a python package and can be used in the python toolchain, including MDS and MFX, as well as in Jupyter notebooks. In a later step it remains to analyze the feasibility of introducing this data container in the .NET toolchain as well.

\section{Implement Processes for Automated NoteSet Generation}
Using different methods and for a set of exemplary currencies a first version of NoteSets are generated from the Data Pool, In the course of this existing client software of MDS and MFX are extended to allow for more complex queries.\par
In a first phase Jupyter Notebooks are used to generate the NoteSets. Different methods and their results, i.e. the resulting NoteSets, will be compared and presented to the Currency Adaptation Team. Once the NoteSet generation process has been refined on a technical level, it remains to decide how to include it in the adaptation specialist's workflow.\par
The NoteSet generation workflow in this development phase can be described as follows: 
\begin{enumerate}
\item Crawl MFX for a chosen currency to obtain all file paths of .NIF files for that currency
\item With a list of all FileIDs and corresponding filepaths, use a labeling method to label all the notes in alle the files
\item Based on the obtained labeling, split the set of all Notes into labelled NoteSets (within a NoteSet, all elements have the same label)
\end{enumerate}
It remains thus to choose a labeling methods. I extracted the following four methods which can be outlined as follows:
\begin{enumerate}
\item For each note in the set of all notes, query MDS to obtain the recognition and classification done by the reader for this note. We use the banknote reader (and the CDF which was loaded at the time of recording) as the labeller. This is the most straightforward way, since all that is done is query existing information from the MDS REST API. No new information is generated.
\item Use the MOVEmSimulator to simulate the reader on the chosen set of notes and a chosen .CDF. Use the information found in the .NIFs generated by the Simulator to group and label the Note Sets. This method is more complicated and time consuming than the first one, but it's also more generic, because it makes us independent from the .CDF which was used in the original recording. For example, the original .CDF used in the actual recording might classify a note as Category 3 (suspected counterfeit), but might now be outdated since the lates .CDF for the same currency classifies the same note as Category 2 (proven counterfeit). On MDS, the information generated in the original recording is stored, therefore, this note will always be a Category 3 note if we use the first method. If we let the simulator process the chosen set of .NIF files first, using the latest CDF, we will get the most up to date information, namely the results a physical reader would calculate using the most recently released .CDF.
\item Load all the notes from the set of all notes into MCM and use algorithm(s) from the algorithmic framework of MCM to determine properties of each note based on which the notes can be labelled. We use MCM as the labeller. To do this in an automated way, a Python wrapper for MCM has to be used, which unfortunately only allows restricted use of MCM.
\item Use an algorithm external to MCM as a kind of plug-in to process and label the notes. This is the most experimental method, but maybe also the most interesting one. It has the advantage that we are free of MCMs monolithic architecture in our labeling process, but also the challenge that the MCM algorithmic framework is highly developed and refined and can hardly be bested by an external classifier.
\end{enumerate}
\par Figure \ref{fig:ns_mds} to \ref{fig:ns_plugin} visualize these different approaches.

\begin{figure}[!htb]
\minipage{0.49\textwidth}
  \includegraphics[width=\linewidth]{images/label_mds_approach.png}
  \caption{NoteSet Generation with MDS labeling}\label{fig:ns_mds}
\endminipage\hfill
\minipage{0.49\textwidth}
  \includegraphics[width=\linewidth]{images/label_simulator_approach.png}
  \caption{NoteSet Generation with MOVEm Simulator labeling}\label{fig:ns_sim}
\endminipage\hfill
\minipage{0.49\textwidth}
  \includegraphics[width=\linewidth]{images/label_mcm_approach.png}
  \caption{NoteSet Generation with MCM labeling}\label{fig:ns_mcm}
\endminipage\hfill
\minipage{0.49\textwidth}%
  \includegraphics[width=\linewidth]{images/label_plugin_approach.png}
  \caption{NoteSetGeneration with Plugin Algorithm}\label{fig:ns_plugin}
\endminipage
\end{figure}

In the course of implementing the project the focus shifted almost entirely on the method of labeling via MDS and the MOVEm Simulator. In a first stage I tried to use MCM as a labeller, but discarded this mainly because of performance reasons. MCM is already a very resource-intensive piece of software and accessing it via a Python wrapper from Jupyter had another negative impact on the performance. In addition, the python wrapper for MCM is quite limited as only a number of MCM functions are accessible and MCM is impossible to debug when accessed via Python. \par
The usage of a plugin algorithm is still a promising option especially if one would like to challenge an existing algorithm (e.g. classifier) by comparing its result with a generic image classifier. It turned out however that the users' main need at this point in time is not to gather new knowledge from the existing data but rather to just find ways of generating useful datasets. Given that the need of introducing a new algorithm was less urgent. 

\section{Introduce NoteSet loading in MCM}
Since MCM already uses MFX, it is able to load NIF files by File ID only, thus nothing stands in the way of loading Notes by ID, i.e. as a set of Note IDs. Therefore a feature is added in MCM which allows loading and exporting of NoteSets. This should be done with as little cost as possible as introducing bigger changes and new models into MCM is always very complex and delicate. The idea is to allow passing NoteSets in the MCM View layer, but converting them into standard MCM Notelist objects before they are passed to deeper layers. 
